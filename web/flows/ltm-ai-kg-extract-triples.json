{
  "id": "ltm-ai-kg-extract-triples",
  "name": "ltm-ai-kg-extract-triples",
  "description": "Extract append-only temporal triple assertions (subject-predicate-object) from a text fragment, using schema-enforced structured output. Intended to be composed into ltm-ai-kg-ingest-* flows.",
  "interfaces": [],
  "nodes": [
    {
      "id": "node-1",
      "type": "on_flow_start",
      "position": { "x": 96.0, "y": 96.0 },
      "data": {
        "nodeType": "on_flow_start",
        "label": "Start",
        "icon": "&#x1F3C1;",
        "headerColor": "#C0392B",
        "inputs": [],
	        "outputs": [
	          { "id": "exec-out", "label": "", "type": "execution" },
	          { "id": "provider", "label": "provider", "type": "provider" },
	          { "id": "model", "label": "model", "type": "model" },
	          { "id": "text", "label": "text", "type": "string" },
	          { "id": "domain_focus", "label": "domain_focus", "type": "string" },
	          { "id": "max_out_tokens", "label": "max_out_tokens", "type": "number" }
	        ],
		        "pinDefaults": {
		          "provider": "lmstudio",
		          "model": "qwen/qwen3-next-80b",
		          "domain_focus": "software / agents / memory systems",
		          "max_out_tokens": 900
		        }
		      }
		    },
    {
      "id": "node-2",
      "type": "literal_json",
      "position": { "x": 96.0, "y": 224.0 },
      "data": {
        "nodeType": "literal_json",
        "label": "Vars",
        "icon": "{}",
        "headerColor": "#00FFFF",
        "inputs": [],
        "outputs": [{ "id": "value", "label": "value", "type": "object" }],
        "literalValue": {}
      }
    },
    {
      "id": "node-3",
      "type": "set",
      "position": { "x": 320.0, "y": 224.0 },
      "data": {
        "nodeType": "set",
        "label": "Set text",
        "icon": "&#x1F4E4;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "value", "label": "value", "type": "any" }
        ],
        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
        "pinDefaults": { "key": "text" }
      }
    },
    {
      "id": "node-4",
      "type": "set",
      "position": { "x": 560.0, "y": 224.0 },
      "data": {
        "nodeType": "set",
        "label": "Set domain_focus",
        "icon": "&#x1F4E4;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "value", "label": "value", "type": "any" }
        ],
        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
        "pinDefaults": { "key": "domain_focus" }
      }
    },
    {
      "id": "node-5",
      "type": "string_template",
      "position": { "x": 800.0, "y": 224.0 },
      "data": {
        "nodeType": "string_template",
        "label": "Build prompt",
        "icon": "&#x1F4DD;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "template", "label": "template", "type": "string" },
          { "id": "vars", "label": "vars", "type": "object" }
        ],
	        "outputs": [{ "id": "result", "label": "result", "type": "string" }],
	        "pinDefaults": {
		          "template": "You are a semantic extractor for an AI long-term memory system.\\n\\nTask: output BETWEEN 6 and 12 high-signal, append-only assertions (subject-predicate-object) supported by TEXT (aim for ~8).\\nOnly output fewer than 6 if the text truly contains fewer distinct atomic facts.\\nDomain focus (only affects what you keep): {{domain_focus}}\\n\\nHard rules:\\n- Only assert what TEXT directly states (no external knowledge).\\n- Output MUST match the enforced structured-output schema: {\\\"assertions\\\":[...]}.\\n- Use ONLY predicates allowed by the schema enum (do not invent new predicates).\\n- If TEXT contains any factual statement, return >=1 assertion (never return empty just because TEXT is short).\\n- attributes.evidence_quote MUST be an exact verbatim substring of TEXT, <=160 chars, no ellipses.\\n- attributes.original_context (optional) MUST be an exact substring of TEXT, <=280 chars, and include evidence_quote.\\n- IDs: use lowercase stable CURIE-like ids. For new entities use ex:{kind}-{kebab-case}.\\n- ID reuse: if the system prompt includes a \\\"## KG ACTIVE MEMORY\\\" block, reuse matching existing ex:* ids (match by rdf:type + primary label). Only mint a new id when no candidate fits.\\n\\nEntity completeness (important):\\n- For every new ex:* entity you introduce, add:\\n  - rdf:type (to one of: skos:Concept, cito:Claim, schema:Event, schema:Person, schema:Organization, schema:Thing, dcterms:Text)\\n  - one primary label:\\n    - concepts → skos:prefLabel\\n    - claims → skos:definition\\n    - events/people/orgs/places → schema:name\\n    - documents → dcterms:title\\n\\nExtraction strategy (do this unless impossible):\\n- Capture 1–3 main statements as cito:Claim + skos:definition (use verbatim evidence_quote text).\\n- Create skos:Concept nodes for key terms, and link claims to them with schema:about / schema:mentions.\\n- Create schema:Event nodes only for explicit happenings.\\n\\nExample (for \\\"Mistakes are opportunities for growth.\\\"):\\n- ex:claim-mistakes-opportunities rdf:type cito:Claim\\n- ex:claim-mistakes-opportunities skos:definition \\\"mistakes are opportunities for growth\\\"\\n- ex:concept-mistake rdf:type skos:Concept\\n- ex:concept-mistake skos:prefLabel \\\"mistakes\\\"\\n- ex:claim-mistakes-opportunities schema:about ex:concept-mistake\\n\\nTEXT:\\n{{text}}"
	        }
	      }
	    },
    {
      "id": "node-6",
      "type": "json_schema",
      "position": { "x": 800.0, "y": 64.0 },
      "data": {
        "nodeType": "json_schema",
        "label": "Triples schema",
        "icon": "&#x1F4CB;",
        "headerColor": "#00FFFF",
        "inputs": [],
	        "outputs": [{ "id": "value", "label": "schema", "type": "object" }],
	        "literalValue": { "$ref": "abstractsemantics:kg_assertion_schema_v0" }
	      }
	    },
    {
      "id": "node-7",
      "type": "llm_call",
      "position": { "x": 1040.0, "y": 96.0 },
      "data": {
        "nodeType": "llm_call",
        "label": "Extract triples",
        "icon": "&#x1F4AD;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "exec-in", "label": "", "type": "execution" },
          { "id": "include_context", "label": "use_context", "type": "boolean" },
          { "id": "provider", "label": "provider", "type": "provider" },
          { "id": "model", "label": "model", "type": "model" },
	          { "id": "temperature", "label": "temperature", "type": "number" },
	          { "id": "seed", "label": "seed", "type": "number" },
	          { "id": "max_out_tokens", "label": "max_out_tokens", "type": "number" },
	          { "id": "system", "label": "system", "type": "string" },
	          { "id": "prompt", "label": "prompt", "type": "string" },
	          { "id": "tools", "label": "tools", "type": "tools" },
          { "id": "response_schema", "label": "structured_output", "type": "object" }
        ],
        "outputs": [
          { "id": "exec-out", "label": "", "type": "execution" },
          { "id": "response", "label": "response", "type": "string" },
          { "id": "tool_calls", "label": "tool_calls", "type": "array" },
          { "id": "result", "label": "result", "type": "object" }
        ],
	        "effectConfig": {
	          "provider": "lmstudio",
	          "model": "qwen/qwen3-next-80b",
	          "temperature": 0.0,
	          "seed": 0,
	          "structured_output_fallback": false
	        },
	        "pinDefaults": {
	          "include_context": false,
	          "use_kg_memory": true,
	          "memory_scope": "session",
	          "recall_level": "standard",
	          "system": "You are a semantic extractor for an AI long-term memory system. Always comply with the provided structured output schema."
	        }
      }
    },
    {
      "id": "node-8",
      "type": "get",
      "position": { "x": 1264.0, "y": 96.0 },
      "data": {
        "nodeType": "get",
        "label": "Get structured.data",
        "icon": "&#x1F4E5;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "default", "label": "default", "type": "any" }
        ],
        "outputs": [{ "id": "value", "label": "value", "type": "any" }],
        "pinDefaults": { "key": "data", "default": {} }
      }
    },
	    {
	      "id": "node-9",
	      "type": "get",
	      "position": { "x": 1488.0, "y": 96.0 },
      "data": {
        "nodeType": "get",
        "label": "Get assertions",
        "icon": "&#x1F4E5;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "default", "label": "default", "type": "any" }
        ],
	        "outputs": [{ "id": "value", "label": "value", "type": "any" }],
	        "pinDefaults": { "key": "assertions", "default": [] }
	      }
	    },
	    {
	      "id": "node-11",
	      "type": "set",
	      "position": { "x": 1264.0, "y": 224.0 },
	      "data": {
	        "nodeType": "set",
	        "label": "Set assertions",
	        "icon": "&#x1F4E4;",
	        "headerColor": "#3498DB",
	        "inputs": [
	          { "id": "object", "label": "object", "type": "object" },
	          { "id": "key", "label": "key", "type": "string" },
	          { "id": "value", "label": "value", "type": "any" }
	        ],
	        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
	        "pinDefaults": { "key": "assertions" }
	      }
	    },
	    {
	      "id": "node-12",
	      "type": "code",
	      "position": { "x": 1488.0, "y": 224.0 },
	      "data": {
	        "nodeType": "code",
	        "label": "Gate assertions",
	        "icon": "&#x1F40D;",
	        "headerColor": "#9B59B6",
	        "inputs": [
	          { "id": "exec-in", "label": "", "type": "execution" },
	          { "id": "input", "label": "input", "type": "any" }
	        ],
	        "outputs": [
	          { "id": "exec-out", "label": "", "type": "execution" },
	          { "id": "output", "label": "output", "type": "any" }
	        ],
	        "functionName": "transform",
	        "code": "def transform(_input):\n    payload = _input.get('input') if isinstance(_input, dict) else None\n    if not isinstance(payload, dict):\n        payload = {}\n\n    text = payload.get('text', '')\n    if not isinstance(text, str):\n        text = str(text or '')\n\n    raw = payload.get('assertions', [])\n    if not isinstance(raw, list):\n        return []\n\n    def _norm_space(s):\n        return ' '.join(s.split()).strip().lower() if isinstance(s, str) else ''\n\n    MAX_EVIDENCE = 160\n    MAX_CONTEXT = 280\n\n    _pred_aliases = {\n        'schema:description': 'dcterms:description',\n        'schema:creator': 'dcterms:creator',\n        'schema:awareness': 'schema:knowsabout',\n        'schema:hasparent': 'dcterms:ispartof',\n        'schema:hasmember': 'dcterms:haspart',\n        'schema:recognizedas': 'skos:closematch',\n        'schema:hasmemorysource': 'dcterms:references',\n        'schema:haspart': 'dcterms:haspart',\n        'schema:ispartof': 'dcterms:ispartof',\n        'dcterms:has_part': 'dcterms:haspart',\n        'dcterms:is_part_of': 'dcterms:ispartof',\n    }\n\n    def _norm_predicate(p):\n        p2 = _norm_space(p)\n        return _pred_aliases.get(p2, p2)\n\n    def _repair_context(evidence, max_len=MAX_CONTEXT):\n        if not isinstance(evidence, str) or not evidence:\n            return ''\n        idx = text.find(evidence)\n        if idx < 0:\n            return ''\n        max_len2 = int(max_len) if isinstance(max_len, (int, float)) else MAX_CONTEXT\n        max_len2 = max(0, max_len2)\n        if max_len2 and max_len2 < len(evidence):\n            max_len2 = len(evidence)\n        window = (max_len2 - len(evidence)) // 2 if max_len2 else 0\n        start = idx - int(window)\n        if start < 0:\n            start = 0\n        end = idx + len(evidence) + int(window)\n        if end > len(text):\n            end = len(text)\n        if max_len2 and (end - start) > max_len2:\n            end = start + max_len2\n        return text[start:end]\n\n    seen = set()\n    out = []\n\n    for a in raw:\n        if not isinstance(a, dict):\n            continue\n\n        subj = _norm_space(a.get('subject'))\n        pred = _norm_predicate(a.get('predicate'))\n        obj = _norm_space(a.get('object'))\n\n        if not subj or not pred or not obj:\n            continue\n\n        attrs = a.get('attributes') if isinstance(a.get('attributes'), dict) else {}\n        ev = attrs.get('evidence_quote')\n        ctx = attrs.get('original_context')\n\n        if not isinstance(ev, str):\n            continue\n        ev2 = ev.strip()\n        if not ev2 or ev2 not in text:\n            continue\n        if len(ev2) > MAX_EVIDENCE:\n            continue\n\n        ctx2 = ctx.strip() if isinstance(ctx, str) else ''\n        if not ctx2 or ctx2 not in text or ev2 not in ctx2:\n            ctx2 = _repair_context(ev2)\n        if not ctx2:\n            # Evidence itself is always acceptable as context.\n            ctx2 = ev2\n        if ctx2 not in text or ev2 not in ctx2:\n            continue\n        if len(ctx2) > MAX_CONTEXT:\n            ctx2 = _repair_context(ev2) or ev2\n\n        key = (subj, pred, obj)\n        if key in seen:\n            continue\n        seen.add(key)\n\n        a2 = {'subject': subj, 'predicate': pred, 'object': obj}\n        for opt_key in ('confidence', 'valid_from', 'valid_until', 'provenance'):\n            if opt_key in a:\n                a2[opt_key] = a.get(opt_key)\n\n        # Preserve semantic typing + grounding fields.\n        a2['attributes'] = {\n            'subject_type': attrs.get('subject_type'),\n            'object_type': attrs.get('object_type'),\n            'evidence_quote': ev2,\n            'original_context': ctx2,\n        }\n\n        out.append(a2)\n        if len(out) >= 12:\n            break\n\n    return out\n"
	      }
	    },
	    {
	      "id": "node-10",
	      "type": "on_flow_end",
	      "position": { "x": 1728.0, "y": 96.0 },
      "data": {
        "nodeType": "on_flow_end",
        "label": "End",
        "icon": "&#x23F9;",
        "headerColor": "#C0392B",
        "inputs": [
          { "id": "exec-in", "label": "", "type": "execution" },
          { "id": "assertions", "label": "assertions", "type": "assertions" },
          { "id": "extraction", "label": "extraction", "type": "object" },
          { "id": "raw", "label": "raw", "type": "string" }
        ],
        "outputs": []
      }
    }
  ],
	  "edges": [
    { "id": "edge-1", "source": "node-1", "sourceHandle": "text", "target": "node-3", "targetHandle": "value", "animated": false },
    { "id": "edge-2", "source": "node-2", "sourceHandle": "value", "target": "node-3", "targetHandle": "object", "animated": false },
    { "id": "edge-3", "source": "node-3", "sourceHandle": "result", "target": "node-4", "targetHandle": "object", "animated": false },
    { "id": "edge-4", "source": "node-1", "sourceHandle": "domain_focus", "target": "node-4", "targetHandle": "value", "animated": false },
    { "id": "edge-5", "source": "node-4", "sourceHandle": "result", "target": "node-5", "targetHandle": "vars", "animated": false },
    { "id": "edge-6", "source": "node-5", "sourceHandle": "result", "target": "node-7", "targetHandle": "prompt", "animated": false },
    { "id": "edge-6b", "source": "node-1", "sourceHandle": "text", "target": "node-7", "targetHandle": "memory_query", "animated": false },
	    { "id": "edge-7", "source": "node-1", "sourceHandle": "provider", "target": "node-7", "targetHandle": "provider", "animated": false },
	    { "id": "edge-8", "source": "node-1", "sourceHandle": "model", "target": "node-7", "targetHandle": "model", "animated": false },
	    { "id": "edge-8b", "source": "node-1", "sourceHandle": "max_out_tokens", "target": "node-7", "targetHandle": "max_out_tokens", "animated": false },
	    { "id": "edge-9", "source": "node-6", "sourceHandle": "value", "target": "node-7", "targetHandle": "response_schema", "animated": false },
    { "id": "edge-10", "source": "node-1", "sourceHandle": "exec-out", "target": "node-7", "targetHandle": "exec-in", "animated": true },
	    { "id": "edge-11", "source": "node-7", "sourceHandle": "result", "target": "node-8", "targetHandle": "object", "animated": false },
	    { "id": "edge-12", "source": "node-8", "sourceHandle": "value", "target": "node-9", "targetHandle": "object", "animated": false },
	    { "id": "edge-13", "source": "node-12", "sourceHandle": "output", "target": "node-10", "targetHandle": "assertions", "animated": false },
	    { "id": "edge-14", "source": "node-8", "sourceHandle": "value", "target": "node-10", "targetHandle": "extraction", "animated": false },
	    { "id": "edge-15", "source": "node-7", "sourceHandle": "response", "target": "node-10", "targetHandle": "raw", "animated": false },
	    { "id": "edge-16", "source": "node-12", "sourceHandle": "exec-out", "target": "node-10", "targetHandle": "exec-in", "animated": true },
	    { "id": "edge-17", "source": "node-4", "sourceHandle": "result", "target": "node-11", "targetHandle": "object", "animated": false },
	    { "id": "edge-18", "source": "node-9", "sourceHandle": "value", "target": "node-11", "targetHandle": "value", "animated": false },
	    { "id": "edge-19", "source": "node-11", "sourceHandle": "result", "target": "node-12", "targetHandle": "input", "animated": false },
	    { "id": "edge-20", "source": "node-7", "sourceHandle": "exec-out", "target": "node-12", "targetHandle": "exec-in", "animated": true }
	  ],
	  "entryNode": "node-1"
	}
