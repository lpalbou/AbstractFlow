{
  "id": "ltm-ai-kg-extract-triples",
  "name": "ltm-ai-kg-extract-triples",
  "description": "Extract append-only temporal triple assertions (subject-predicate-object) from a text fragment, using schema-enforced structured output. Intended to be composed into ltm-ai-kg-ingest-* flows.",
  "interfaces": [],
  "nodes": [
    {
      "id": "node-1",
      "type": "on_flow_start",
      "position": { "x": 96.0, "y": 96.0 },
      "data": {
        "nodeType": "on_flow_start",
        "label": "Start",
        "icon": "&#x1F3C1;",
        "headerColor": "#C0392B",
        "inputs": [],
	        "outputs": [
	          { "id": "exec-out", "label": "", "type": "execution" },
	          { "id": "provider", "label": "provider", "type": "provider" },
	          { "id": "model", "label": "model", "type": "model" },
	          { "id": "text", "label": "text", "type": "string" },
	          { "id": "domain_focus", "label": "domain_focus", "type": "string" },
	          { "id": "max_out_tokens", "label": "max_out_tokens", "type": "number" }
	        ],
		        "pinDefaults": {
		          "provider": "lmstudio",
		          "model": "qwen/qwen3-next-80b",
		          "domain_focus": "software / agents / memory systems",
		          "max_out_tokens": 500
		        }
		      }
		    },
    {
      "id": "node-2",
      "type": "literal_json",
      "position": { "x": 96.0, "y": 224.0 },
      "data": {
        "nodeType": "literal_json",
        "label": "Vars",
        "icon": "{}",
        "headerColor": "#00FFFF",
        "inputs": [],
        "outputs": [{ "id": "value", "label": "value", "type": "object" }],
        "literalValue": {}
      }
    },
    {
      "id": "node-3",
      "type": "set",
      "position": { "x": 320.0, "y": 224.0 },
      "data": {
        "nodeType": "set",
        "label": "Set text",
        "icon": "&#x1F4E4;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "value", "label": "value", "type": "any" }
        ],
        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
        "pinDefaults": { "key": "text" }
      }
    },
    {
      "id": "node-4",
      "type": "set",
      "position": { "x": 560.0, "y": 224.0 },
      "data": {
        "nodeType": "set",
        "label": "Set domain_focus",
        "icon": "&#x1F4E4;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "value", "label": "value", "type": "any" }
        ],
        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
        "pinDefaults": { "key": "domain_focus" }
      }
    },
    {
      "id": "node-5",
      "type": "string_template",
      "position": { "x": 800.0, "y": 224.0 },
      "data": {
        "nodeType": "string_template",
        "label": "Build prompt",
        "icon": "&#x1F4DD;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "template", "label": "template", "type": "string" },
          { "id": "vars", "label": "vars", "type": "object" }
        ],
	        "outputs": [{ "id": "result", "label": "result", "type": "string" }],
	        "pinDefaults": {
		          "template": "You are a semantic extractor for an AI long-term memory system.\\n\\nTask: extract a small set of high-signal, append-only assertions (subject-predicate-object) from TEXT.\\nDomain focus: {{domain_focus}}\\n\\nHard rules:\\n- Only assert what TEXT directly states (no external knowledge).\\n- Output MUST match the enforced structured-output schema.\\n- Use ONLY predicates from the schema enum (do not invent new predicates; do not emit schema:creator/schema:description).\\n- Evidence: attributes.evidence_quote MUST be an exact verbatim substring of TEXT and MUST be short (<=160 chars). No ellipses.\\n- attributes.original_context is OPTIONAL; if provided, keep it short (<=280 chars) and verbatim.\\n- Prefer 6-10 assertions (max 12). If TEXT is purely a request/command with no factual content, it is OK to return an empty list.\\n\\nModeling guidance:\\n- Events: mint ex:event-* and use rdf:type schema:Event + schema:name + schema:participant + time/location when present.\\n- New entities: mint ex:{kind}-{kebab-case} (lowercase, stable).\\n\\nTEXT:\\n{{text}}"
		        }
		      }
		    },
    {
      "id": "node-6",
      "type": "json_schema",
      "position": { "x": 800.0, "y": 64.0 },
      "data": {
        "nodeType": "json_schema",
        "label": "Triples schema",
        "icon": "&#x1F4CB;",
        "headerColor": "#00FFFF",
        "inputs": [],
	        "outputs": [{ "id": "value", "label": "schema", "type": "object" }],
	        "literalValue": {
	          "type": "object",
	          "properties": {
	            "assertions": {
	              "type": "array",
	              "items": {
	                "type": "object",
	                "properties": {
	                  "subject": { "type": "string" },
	                  "predicate": {
	                    "type": "string",
	                    "enum": [
	                      "rdf:type",
	                      "dcterms:hasPart",
	                      "dcterms:isPartOf",
	                      "schema:nextItem",
	                      "schema:previousItem",
		                      "dcterms:identifier",
		                      "dcterms:title",
		                      "schema:name",
		                      "dcterms:description",
	                      "dcterms:abstract",
	                      "dcterms:created",
	                      "dcterms:modified",
	                      "dcterms:creator",
	                      "dcterms:publisher",
	                      "dcterms:subject",
	                      "schema:genre",
			                      "schema:about",
			                      "schema:mentions",
			                      "schema:knowsAbout",
			                      "dcterms:references",
			                      "schema:sameAs",
			                      "schema:location",
	                      "schema:temporalCoverage",
	                      "schema:participant",
	                      "schema:organizer",
	                      "schema:result",
	                      "schema:instrument",
	                      "schema:startDate",
	                      "schema:endDate",
	                      "skos:definition",
	                      "skos:prefLabel",
	                      "skos:altLabel",
	                      "skos:broader",
	                      "skos:narrower",
	                      "skos:related",
	                      "skos:exactMatch",
	                      "skos:closeMatch",
	                      "cito:supports",
	                      "cito:disagreesWith",
		                      "cito:usesDataFrom",
		                      "cito:providesDataFor",
		                      "cito:extends",
		                      "cito:discusses",
		                      "cito:confirms",

		                      "schema:description",
		                      "schema:creator",
		                      "schema:hasParent",
		                      "schema:hasMember",
		                      "schema:hasMemorySource",
		                      "schema:recognizedAs"
		                    ]
		                  },
	                  "object": { "type": "string" },
	                  "confidence": { "type": ["number", "null"], "minimum": 0, "maximum": 1 },
	                  "valid_from": { "type": ["string", "null"] },
	                  "valid_until": { "type": ["string", "null"] },
	                  "provenance": { "type": ["object", "null"] },
	                  "attributes": {
	                    "type": "object",
		                    "properties": {
		                      "subject_type": {
		                        "type": "string",
		                        "enum": [
		                          "schema:Thing",
		                          "dcterms:Text",
		                          "dcterms:Collection",
		                          "skos:Concept",
		                          "cito:Claim",
		                          "schema:Person",
		                          "schema:Organization",
		                          "schema:ItemList",
		                          "schema:SoftwareApplication",
		                          "schema:Event",
		                          "schema:Place",
		                          "schema:Country",
		                          "schema:Product",
		                          "schema:Dataset",
		                          "schema:ImageObject",
		                          "schema:VideoObject",
		                          "schema:Table",
		                          "schema:SoftwareSourceCode"
		                        ]
		                      },
		                      "object_type": {
		                        "type": "string",
		                        "enum": [
		                          "schema:Thing",
		                          "dcterms:Text",
		                          "dcterms:Collection",
		                          "skos:Concept",
		                          "cito:Claim",
		                          "schema:Person",
		                          "schema:Organization",
		                          "schema:ItemList",
		                          "schema:SoftwareApplication",
		                          "schema:Event",
		                          "schema:Place",
		                          "schema:Country",
		                          "schema:Product",
		                          "schema:Dataset",
		                          "schema:ImageObject",
		                          "schema:VideoObject",
		                          "schema:Table",
		                          "schema:SoftwareSourceCode"
		                        ]
		                      },
				                      "evidence_quote": { "type": "string", "maxLength": 160 },
				                      "original_context": { "type": "string", "maxLength": 280 }
				                    },
			                    "required": ["evidence_quote"]
			                  }
	                },
	                "required": ["subject", "predicate", "object", "attributes"]
	              }
	            }
	          },
	          "required": ["assertions"]
	        }
	      }
	    },
    {
      "id": "node-7",
      "type": "llm_call",
      "position": { "x": 1040.0, "y": 96.0 },
      "data": {
        "nodeType": "llm_call",
        "label": "Extract triples",
        "icon": "&#x1F4AD;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "exec-in", "label": "", "type": "execution" },
          { "id": "include_context", "label": "use_context", "type": "boolean" },
          { "id": "provider", "label": "provider", "type": "provider" },
          { "id": "model", "label": "model", "type": "model" },
	          { "id": "temperature", "label": "temperature", "type": "number" },
	          { "id": "seed", "label": "seed", "type": "number" },
	          { "id": "max_out_tokens", "label": "max_out_tokens", "type": "number" },
	          { "id": "system", "label": "system", "type": "string" },
	          { "id": "prompt", "label": "prompt", "type": "string" },
	          { "id": "tools", "label": "tools", "type": "tools" },
          { "id": "response_schema", "label": "structured_output", "type": "object" }
        ],
        "outputs": [
          { "id": "exec-out", "label": "", "type": "execution" },
          { "id": "response", "label": "response", "type": "string" },
          { "id": "tool_calls", "label": "tool_calls", "type": "array" },
          { "id": "result", "label": "result", "type": "object" }
        ],
	        "effectConfig": {
	          "provider": "lmstudio",
	          "model": "qwen/qwen3-next-80b",
	          "temperature": 0.0,
	          "seed": 0,
	          "structured_output_fallback": false
	        },
	        "pinDefaults": {
	          "include_context": false,
	          "system": "You are a semantic extractor for an AI long-term memory system. Always comply with the provided structured output schema."
	        }
      }
    },
    {
      "id": "node-8",
      "type": "get",
      "position": { "x": 1264.0, "y": 96.0 },
      "data": {
        "nodeType": "get",
        "label": "Get structured.data",
        "icon": "&#x1F4E5;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "default", "label": "default", "type": "any" }
        ],
        "outputs": [{ "id": "value", "label": "value", "type": "any" }],
        "pinDefaults": { "key": "data", "default": {} }
      }
    },
	    {
	      "id": "node-9",
	      "type": "get",
	      "position": { "x": 1488.0, "y": 96.0 },
      "data": {
        "nodeType": "get",
        "label": "Get assertions",
        "icon": "&#x1F4E5;",
        "headerColor": "#3498DB",
        "inputs": [
          { "id": "object", "label": "object", "type": "object" },
          { "id": "key", "label": "key", "type": "string" },
          { "id": "default", "label": "default", "type": "any" }
        ],
	        "outputs": [{ "id": "value", "label": "value", "type": "any" }],
	        "pinDefaults": { "key": "assertions", "default": [] }
	      }
	    },
	    {
	      "id": "node-11",
	      "type": "set",
	      "position": { "x": 1264.0, "y": 224.0 },
	      "data": {
	        "nodeType": "set",
	        "label": "Set assertions",
	        "icon": "&#x1F4E4;",
	        "headerColor": "#3498DB",
	        "inputs": [
	          { "id": "object", "label": "object", "type": "object" },
	          { "id": "key", "label": "key", "type": "string" },
	          { "id": "value", "label": "value", "type": "any" }
	        ],
	        "outputs": [{ "id": "result", "label": "result", "type": "object" }],
	        "pinDefaults": { "key": "assertions" }
	      }
	    },
	    {
	      "id": "node-12",
	      "type": "code",
	      "position": { "x": 1488.0, "y": 224.0 },
	      "data": {
	        "nodeType": "code",
	        "label": "Gate assertions",
	        "icon": "&#x1F40D;",
	        "headerColor": "#9B59B6",
	        "inputs": [
	          { "id": "exec-in", "label": "", "type": "execution" },
	          { "id": "input", "label": "input", "type": "any" }
	        ],
	        "outputs": [
	          { "id": "exec-out", "label": "", "type": "execution" },
	          { "id": "output", "label": "output", "type": "any" }
	        ],
	        "functionName": "transform",
	        "code": "def transform(_input):\n    payload = _input.get('input') if isinstance(_input, dict) else None\n    if not isinstance(payload, dict):\n        payload = {}\n\n    text = payload.get('text', '')\n    if not isinstance(text, str):\n        text = str(text or '')\n\n    raw = payload.get('assertions', [])\n    if not isinstance(raw, list):\n        return []\n\n    def _norm_space(s):\n        return ' '.join(s.split()).strip().lower() if isinstance(s, str) else ''\n\n    _pred_aliases = {\n        'schema:description': 'dcterms:description',\n        'schema:creator': 'dcterms:creator',\n        'schema:awareness': 'schema:knowsabout',\n        'schema:hasparent': 'dcterms:ispartof',\n        'schema:hasmember': 'dcterms:haspart',\n        'schema:recognizedas': 'skos:closematch',\n        'schema:hasmemorysource': 'dcterms:references',\n        'schema:haspart': 'dcterms:haspart',\n        'schema:ispartof': 'dcterms:ispartof',\n        'dcterms:has_part': 'dcterms:haspart',\n        'dcterms:is_part_of': 'dcterms:ispartof',\n    }\n\n    def _norm_predicate(p):\n        p2 = _norm_space(p)\n        return _pred_aliases.get(p2, p2)\n\n    def _repair_context(evidence, window=200):\n        if not isinstance(evidence, str) or not evidence:\n            return ''\n        idx = text.find(evidence)\n        if idx < 0:\n            return ''\n        start = idx - int(window)\n        if start < 0:\n            start = 0\n        end = idx + len(evidence) + int(window)\n        if end > len(text):\n            end = len(text)\n        return text[start:end]\n\n    seen = set()\n    out = []\n\n    for a in raw:\n        if not isinstance(a, dict):\n            continue\n\n        subj = _norm_space(a.get('subject'))\n        pred = _norm_predicate(a.get('predicate'))\n        obj = _norm_space(a.get('object'))\n\n        if not subj or not pred or not obj:\n            continue\n\n        attrs = a.get('attributes') if isinstance(a.get('attributes'), dict) else {}\n        ev = attrs.get('evidence_quote')\n        ctx = attrs.get('original_context')\n\n        if not isinstance(ev, str):\n            continue\n        ev2 = ev.strip()\n        if not ev2 or ev2 not in text:\n            continue\n\n        ctx2 = ctx.strip() if isinstance(ctx, str) else ''\n        if not ctx2 or ctx2 not in text:\n            ctx2 = _repair_context(ev2)\n        if not ctx2:\n            # Evidence itself is always acceptable as context.\n            ctx2 = ev2\n        if ctx2 not in text:\n            continue\n\n        key = (subj, pred, obj)\n        if key in seen:\n            continue\n        seen.add(key)\n\n        a2 = {'subject': subj, 'predicate': pred, 'object': obj}\n        for opt_key in ('confidence', 'valid_from', 'valid_until', 'provenance'):\n            if opt_key in a:\n                a2[opt_key] = a.get(opt_key)\n\n        # Preserve semantic typing + grounding fields.\n        a2['attributes'] = {\n            'subject_type': attrs.get('subject_type'),\n            'object_type': attrs.get('object_type'),\n            'evidence_quote': ev2,\n            'original_context': ctx2,\n        }\n\n        out.append(a2)\n        if len(out) >= 30:\n            break\n\n    return out\n"
	      }
	    },
	    {
	      "id": "node-10",
	      "type": "on_flow_end",
	      "position": { "x": 1728.0, "y": 96.0 },
      "data": {
        "nodeType": "on_flow_end",
        "label": "End",
        "icon": "&#x23F9;",
        "headerColor": "#C0392B",
        "inputs": [
          { "id": "exec-in", "label": "", "type": "execution" },
          { "id": "assertions", "label": "assertions", "type": "array" },
          { "id": "extraction", "label": "extraction", "type": "object" },
          { "id": "raw", "label": "raw", "type": "string" }
        ],
        "outputs": []
      }
    }
  ],
	  "edges": [
    { "id": "edge-1", "source": "node-1", "sourceHandle": "text", "target": "node-3", "targetHandle": "value", "animated": false },
    { "id": "edge-2", "source": "node-2", "sourceHandle": "value", "target": "node-3", "targetHandle": "object", "animated": false },
    { "id": "edge-3", "source": "node-3", "sourceHandle": "result", "target": "node-4", "targetHandle": "object", "animated": false },
    { "id": "edge-4", "source": "node-1", "sourceHandle": "domain_focus", "target": "node-4", "targetHandle": "value", "animated": false },
    { "id": "edge-5", "source": "node-4", "sourceHandle": "result", "target": "node-5", "targetHandle": "vars", "animated": false },
    { "id": "edge-6", "source": "node-5", "sourceHandle": "result", "target": "node-7", "targetHandle": "prompt", "animated": false },
	    { "id": "edge-7", "source": "node-1", "sourceHandle": "provider", "target": "node-7", "targetHandle": "provider", "animated": false },
	    { "id": "edge-8", "source": "node-1", "sourceHandle": "model", "target": "node-7", "targetHandle": "model", "animated": false },
	    { "id": "edge-8b", "source": "node-1", "sourceHandle": "max_out_tokens", "target": "node-7", "targetHandle": "max_out_tokens", "animated": false },
	    { "id": "edge-9", "source": "node-6", "sourceHandle": "value", "target": "node-7", "targetHandle": "response_schema", "animated": false },
    { "id": "edge-10", "source": "node-1", "sourceHandle": "exec-out", "target": "node-7", "targetHandle": "exec-in", "animated": true },
	    { "id": "edge-11", "source": "node-7", "sourceHandle": "result", "target": "node-8", "targetHandle": "object", "animated": false },
	    { "id": "edge-12", "source": "node-8", "sourceHandle": "value", "target": "node-9", "targetHandle": "object", "animated": false },
	    { "id": "edge-13", "source": "node-12", "sourceHandle": "output", "target": "node-10", "targetHandle": "assertions", "animated": false },
	    { "id": "edge-14", "source": "node-8", "sourceHandle": "value", "target": "node-10", "targetHandle": "extraction", "animated": false },
	    { "id": "edge-15", "source": "node-7", "sourceHandle": "response", "target": "node-10", "targetHandle": "raw", "animated": false },
	    { "id": "edge-16", "source": "node-12", "sourceHandle": "exec-out", "target": "node-10", "targetHandle": "exec-in", "animated": true },
	    { "id": "edge-17", "source": "node-4", "sourceHandle": "result", "target": "node-11", "targetHandle": "object", "animated": false },
	    { "id": "edge-18", "source": "node-9", "sourceHandle": "value", "target": "node-11", "targetHandle": "value", "animated": false },
	    { "id": "edge-19", "source": "node-11", "sourceHandle": "result", "target": "node-12", "targetHandle": "input", "animated": false },
	    { "id": "edge-20", "source": "node-7", "sourceHandle": "exec-out", "target": "node-12", "targetHandle": "exec-in", "animated": true }
	  ],
	  "entryNode": "node-1"
	}
