/**
 * Flow serialization utilities.
 */

import type { Node, Edge } from 'reactflow';
import type { FlowNodeData, VisualFlow, VisualNode, VisualEdge } from '../types/flow';
import { getNodeTemplate, createNodeData, mergePinDocsFromTemplate } from '../types/nodes';

/**
 * Convert React Flow nodes/edges to VisualFlow format for API.
 */
export function toVisualFlow(
  id: string,
  name: string,
  nodes: Node<FlowNodeData>[],
  edges: Edge[]
): VisualFlow {
  const visualNodes: VisualNode[] = nodes.map((node) => ({
    id: node.id,
    type: node.data.nodeType,
    position: node.position,
    data: node.data,
  }));

  const visualEdges: VisualEdge[] = edges.map((edge) => ({
    id: edge.id,
    source: edge.source,
    sourceHandle: edge.sourceHandle || '',
    target: edge.target,
    targetHandle: edge.targetHandle || '',
    animated: edge.animated,
  }));

  // Determine entry node (first node without incoming execution edge)
  const targetIds = new Set(
    edges
      .filter((e) => e.targetHandle === 'exec-in')
      .map((e) => e.target)
  );
  const entryNode = nodes.find((n) => !targetIds.has(n.id))?.id;

  return {
    id,
    name,
    nodes: visualNodes,
    edges: visualEdges,
    entryNode,
  };
}

/**
 * Convert VisualFlow to React Flow nodes/edges.
 */
export function fromVisualFlow(flow: VisualFlow): {
  nodes: Node<FlowNodeData>[];
  edges: Edge[];
} {
  const nodes: Node<FlowNodeData>[] = flow.nodes.map((vn) => {
    // Get template for node type
    const template = getNodeTemplate(vn.type);

    // Create node data from template, merged with saved data
    const dataBase: FlowNodeData = template
      ? { ...createNodeData(template), ...vn.data }
      : vn.data;
    const data: FlowNodeData =
      template ? mergePinDocsFromTemplate(createNodeData(template), dataBase) : dataBase;

    // Best-effort migrations for legacy nodes (keep flows usable across versions).
    if (data.nodeType === 'compare') {
      const hasOp = Array.isArray(data.inputs) && data.inputs.some((p) => p.id === 'op');
      if (!hasOp && Array.isArray(data.inputs)) {
        const nextInputs = [...data.inputs];
        const opPin = { id: 'op', label: 'op', type: 'string' as const };
        const aIdx = nextInputs.findIndex((p) => p.id === 'a');
        if (aIdx >= 0) {
          nextInputs.splice(aIdx + 1, 0, opPin);
        } else {
          nextInputs.push(opPin);
        }
        (data as any).inputs = nextInputs;
      }
    }

    // Agent node: add max_iterations input pin (runtime budget control) for legacy flows.
    if (data.nodeType === 'agent') {
      const hasMax = Array.isArray(data.inputs) && data.inputs.some((p) => p.id === 'max_iterations');
      if (!hasMax && Array.isArray(data.inputs)) {
        const nextInputs = [...data.inputs];
        const maxPin = { id: 'max_iterations', label: 'max_iterations', type: 'number' as const };
        const modelIdx = nextInputs.findIndex((p) => p.id === 'model');
        if (modelIdx >= 0) {
          nextInputs.splice(modelIdx + 1, 0, maxPin);
        } else {
          nextInputs.push(maxPin);
        }
        (data as any).inputs = nextInputs;
      }
    }

    return {
      id: vn.id,
      type: vn.type === 'code' ? 'code' : 'custom',
      position: vn.position,
      data,
    };
  });

  const edges: Edge[] = flow.edges.map((ve) => ({
    id: ve.id,
    source: ve.source,
    sourceHandle: ve.sourceHandle,
    target: ve.target,
    targetHandle: ve.targetHandle,
    animated: ve.animated ?? ve.sourceHandle === 'exec-out',
  }));

  return { nodes, edges };
}

/**
 * Export flow to JSON string.
 */
export function exportFlowToJson(flow: VisualFlow): string {
  return JSON.stringify(flow, null, 2);
}

/**
 * Import flow from JSON string.
 */
export function importFlowFromJson(json: string): VisualFlow {
  const parsed = JSON.parse(json);

  // Validate required fields
  if (!parsed.id || !parsed.name || !Array.isArray(parsed.nodes)) {
    throw new Error('Invalid flow format');
  }

  return parsed as VisualFlow;
}

/**
 * Generate Python code from a visual flow (for export/reference).
 */
export function generatePythonCode(flow: VisualFlow): string {
  const lines: string[] = [
    '"""Generated by AbstractFlow Visual Editor."""',
    '',
    'from abstractflow import Flow, FlowRunner',
    '',
    `flow = Flow("${flow.id}")`,
    '',
    '# Add nodes',
  ];

  for (const node of flow.nodes) {
    const nodeType = node.data.nodeType;
    let handler = 'lambda x: x';

    if (nodeType === 'code' && node.data.code) {
      // Include the code inline (simplified)
      handler = `eval('''${node.data.code.replace(/'/g, "\\'")}''')`;
    } else if (nodeType === 'agent') {
      handler = `create_agent(...)  # Configure agent`;
    } else {
      // Built-in functions
      handler = `builtin_${nodeType}`;
    }

    const inputKey = node.data.inputKey
      ? `, input_key="${node.data.inputKey}"`
      : '';
    const outputKey = node.data.outputKey
      ? `, output_key="${node.data.outputKey}"`
      : '';

    lines.push(
      `flow.add_node("${node.id}", ${handler}${inputKey}${outputKey})`
    );
  }

  lines.push('');
  lines.push('# Add edges');

  for (const edge of flow.edges) {
    if (edge.sourceHandle === 'exec-out' && edge.targetHandle === 'exec-in') {
      lines.push(`flow.add_edge("${edge.source}", "${edge.target}")`);
    }
  }

  if (flow.entryNode) {
    lines.push('');
    lines.push(`flow.set_entry("${flow.entryNode}")`);
  }

  lines.push('');
  lines.push('# Run the flow');
  lines.push('runner = FlowRunner(flow)');
  lines.push('result = runner.run({})');
  lines.push('print(result)');

  return lines.join('\n');
}
