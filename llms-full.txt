# AbstractFlow (Full Context)

> Generated file: concatenated docs for offline/agentic consumption. Prefer `llms.txt` as an index and treat the original files as source of truth.

Generated by: `scripts/generate_llms_full.py`

Included files (repo-root relative):
- README.md
- docs/README.md
- docs/getting-started.md
- docs/api.md
- docs/faq.md
- docs/visualflow.md
- docs/web-editor.md
- docs/cli.md
- docs/architecture.md
- CHANGELOG.md
- CONTRIBUTING.md
- SECURITY.md
- ACKNOWLEDMENTS.md

---
file: README.md
---

# AbstractFlow

Diagram-based, **durable** AI workflows for Python.

AbstractFlow provides:
- A portable workflow format (`VisualFlow` JSON) and helpers to execute it from any host (`abstractflow.visual`).
- A simple programmatic API (`Flow`, `FlowRunner`) backed by **AbstractRuntime**.
- A reference visual editor app in `web/` (FastAPI backend + React frontend).

Project status: **Pre-alpha** (`pyproject.toml`: `Development Status :: 2 - Pre-Alpha`). Expect breaking changes.

## Capabilities (implemented)

- Execute programmatic flows (`Flow` ‚Üí `FlowRunner`) with a default in-memory runtime.
- Execute portable `VisualFlow` JSON from any host process (`abstractflow.visual`).
- Durable waits and resumption via AbstractRuntime (e.g. user/event/schedule waits).
- Package a flow tree as a WorkflowBundle (`.flow`) via the CLI.
- Author/run VisualFlows in the reference web editor (`web/`).

Evidence (code): `abstractflow/runner.py`, `abstractflow/visual/executor.py`, `abstractflow/cli.py`, `web/backend/routes/ws.py`.

## Docs

- Start here: `docs/getting-started.md`
- API reference: `docs/api.md`
- VisualFlow format: `docs/visualflow.md`
- Visual editor: `docs/web-editor.md`
- CLI: `docs/cli.md`
- FAQ: `docs/faq.md`
- Architecture: `docs/architecture.md`
- Docs index: `docs/README.md`

## Installation

```bash
pip install abstractflow
```

Requirements: Python **3.10+** (`pyproject.toml`: `requires-python`).

Optional extras:
- Agent nodes (ReAct workflows): `pip install "abstractflow[agent]"`
- Dev tools (tests/formatting): `pip install "abstractflow[dev]"`

Notes:
- `abstractflow` depends on `AbstractRuntime` and `abstractcore[tools]` (see `pyproject.toml`).
- Some VisualFlow node types require additional packages (e.g. `memory_kg_*` nodes need `abstractmemory`).

## Quickstart (programmatic)

```python
from abstractflow import Flow, FlowRunner

flow = Flow("linear")
flow.add_node("double", lambda x: x * 2, input_key="value", output_key="doubled")
flow.add_node("add_ten", lambda x: x + 10, input_key="doubled", output_key="final")
flow.add_edge("double", "add_ten")
flow.set_entry("double")

result = FlowRunner(flow).run({"value": 5})
print(result)  # {"success": True, "result": 20}
```

## Quickstart (execute a VisualFlow JSON)

```python
import json
from abstractflow.visual import VisualFlow, execute_visual_flow

with open("my-flow.json", "r", encoding="utf-8") as f:
    vf = VisualFlow.model_validate(json.load(f))
result = execute_visual_flow(vf, {"prompt": "Hello"}, flows={vf.id: vf})
print(result)  # {"success": True, "waiting": False, "result": ...}
```

If your flow uses subflows, load all referenced `*.json` into the `flows={...}` mapping (see `docs/getting-started.md`).

## Visual editor (from source)

The visual editor is a dev/reference app in `web/` (not shipped as a Python package on PyPI).

```bash
git clone https://github.com/lpalbou/AbstractFlow.git
cd AbstractFlow

python -m venv .venv
source .venv/bin/activate
pip install -e ".[server,agent]"

# Terminal 1: Backend (FastAPI)
cd web && python -m backend --reload --port 8080

# Terminal 2: Frontend (Vite)
cd web/frontend && npm install && npm run dev
```

Open the frontend at http://localhost:3003 (default Vite port). See `docs/web-editor.md`.

## CLI (WorkflowBundle `.flow`)

```bash
abstractflow bundle pack web/flows/ac-echo.json --out /tmp/ac-echo.flow
abstractflow bundle inspect /tmp/ac-echo.flow
abstractflow bundle unpack /tmp/ac-echo.flow --dir /tmp/ac-echo
```

See `docs/cli.md` and `abstractflow/cli.py`.

## Related projects

- AbstractRuntime (durable execution kernel): https://github.com/lpalbou/AbstractRuntime
- AbstractCore (providers/models/tools): https://github.com/lpalbou/AbstractCore
- AbstractAgent (ReAct/CodeAct): https://github.com/lpalbou/AbstractAgent

## Changelog

See `CHANGELOG.md`.

## Contributing

See `CONTRIBUTING.md`.

## Security

See `SECURITY.md`.

## Acknowledgments

See `ACKNOWLEDMENTS.md`.

## License

MIT. See `LICENSE`.

---
file: docs/README.md
---

# AbstractFlow documentation

AbstractFlow is a Python library + reference UI for authoring and executing **durable** AI workflows.

All file paths in this doc set are relative to the repository root.

## Read this first

- Project overview + install: `README.md`
- Getting started (install + quickstarts): `docs/getting-started.md`
- FAQ (common questions): `docs/faq.md`
- API reference (high-level): `docs/api.md`
- VisualFlow JSON format (portable workflow document): `docs/visualflow.md`
- Visual editor (FastAPI + React dev app): `docs/web-editor.md`
- CLI (`abstractflow bundle ‚Ä¶`): `docs/cli.md`
- Architecture (how the pieces fit): `docs/architecture.md`

## Repo policies

- Changelog: `CHANGELOG.md`
- Contributing: `CONTRIBUTING.md`
- Security reporting: `SECURITY.md`
- Acknowledgments: `ACKNOWLEDMENTS.md`

## Code map (evidence)

- Public Python API: `abstractflow/__init__.py`
- Programmatic flows: `abstractflow/core/flow.py` (re-export from AbstractRuntime)
- Flow execution: `abstractflow/runner.py` (`FlowRunner`)
- VisualFlow schema: `abstractflow/visual/models.py` (`VisualFlow`, `VisualNode`, `NodeType`, ‚Ä¶)
- VisualFlow execution wiring: `abstractflow/visual/executor.py` (`create_visual_runner`, `execute_visual_flow`)
- VisualFlow interfaces/contracts: `abstractflow/visual/interfaces.py`
- CLI entrypoint: `abstractflow/cli.py`
- WorkflowBundle utilities: `abstractflow/workflow_bundle.py` (delegates to `abstractruntime.workflow_bundle`)
- Web backend: `web/backend/main.py`, `web/backend/routes/*`
- Web frontend: `web/frontend/src/*`

---
file: docs/getting-started.md
---

# Getting started

This guide covers the two primary ways to use AbstractFlow:
- **Programmatic flows** (`Flow` + `FlowRunner`)
- **Visual flows** (portable `VisualFlow` JSON authored by the editor in `web/`)

See also: `docs/README.md`, `docs/api.md`, `docs/faq.md`, `docs/visualflow.md`, `docs/web-editor.md`, `docs/cli.md`, `docs/architecture.md`.

## Requirements

- Python **3.10+** (`pyproject.toml`: `requires-python`)

## Install

```bash
# From PyPI
pip install abstractflow
```

Optional extras:
- Agent nodes (ReAct workflows): `pip install "abstractflow[agent]"`
- Dev tools: `pip install "abstractflow[dev]"`

From source (repo root):

```bash
pip install -e .
```

Evidence: dependencies and extras are declared in `pyproject.toml`.

## Programmatic flow (FlowRunner)

```python
from abstractflow import Flow, FlowRunner

flow = Flow("linear")
flow.add_node("double", lambda x: x * 2, input_key="value", output_key="doubled")
flow.add_node("add_ten", lambda x: x + 10, input_key="doubled", output_key="final")
flow.add_edge("double", "add_ten")
flow.set_entry("double")

print(FlowRunner(flow).run({"value": 5}))
# {"success": True, "result": 20}
```

Evidence:
- `Flow` / `FlowNode` / `FlowEdge` are re-exported from AbstractRuntime: `abstractflow/core/flow.py`
- `FlowRunner` output normalization is implemented in `abstractflow/runner.py`
- Baseline behavior is covered in `tests/test_runner.py`

## Execute a VisualFlow JSON

Visual flows are JSON documents matching the Pydantic models in `abstractflow/visual/models.py`.

Minimal example (single flow, no subflows):

```python
import json
from abstractflow.visual import VisualFlow, execute_visual_flow

with open("my-flow.json", "r", encoding="utf-8") as f:
    vf = VisualFlow.model_validate(json.load(f))
print(execute_visual_flow(vf, {"prompt": "Hello"}, flows={vf.id: vf}))
```

If your flow uses subflows:
- load **all referenced** `*.json` flows into the `flows={flow_id: VisualFlow}` mapping, or
- package them as a WorkflowBundle (`.flow`) and load via AbstractRuntime (see `docs/cli.md`).

Convenient loader:

```python
from pathlib import Path
import json
from abstractflow.visual import VisualFlow

def load_flows(dir_path: str) -> dict[str, VisualFlow]:
    flows: dict[str, VisualFlow] = {}
    for p in Path(dir_path).glob("*.json"):
        vf = VisualFlow.model_validate(json.loads(p.read_text(encoding="utf-8")))
        flows[vf.id] = vf
    return flows
```

Evidence:
- VisualFlow execution wiring lives in `abstractflow/visual/executor.py` (`create_visual_runner`, `execute_visual_flow`)
- Subflow reachability / registry behavior is exercised in `tests/test_visual_subflow_*.py`

## Run the visual editor (from source)

The editor is a reference/dev app in `web/` (FastAPI backend + React frontend). Follow: `docs/web-editor.md`.

Tip: install the backend deps from the repo root with `pip install -e ".[server,agent]"`.

## Workflow bundles (`.flow`)

To package a VisualFlow + subflows into a single file, use the CLI:
- `docs/cli.md`

## Waiting runs (durable asks/events/schedules)

Some flows intentionally block waiting for external input (e.g. `ask_user`, `wait_event`, `wait_until`).

- `FlowRunner.run()` returns `{"waiting": True, "state": <RunState>, ...}` when blocked (`abstractflow/runner.py`).
- `execute_visual_flow()` returns a friendly shape including `waiting`, `wait_key`, and optional UX fields (`prompt`, `choices`, `allow_free_text`) (`abstractflow/visual/executor.py`).
  - Note: waiting results are reported as `success: False` with an `error` message (the run is not ‚Äúfailed‚Äù; it is blocked on input).

To resume a run you need a host that can call `Runtime.resume(...)` (the web editor does this via WebSocket; see `docs/web-editor.md`).

---
file: docs/api.md
---

# API reference (high-level)

This page documents the public Python API surface of the `abstractflow` package.

See also: `README.md`, `docs/getting-started.md`, `docs/architecture.md`, `docs/faq.md`.

## Version

- `abstractflow.__version__` (string)

Evidence: `abstractflow/__init__.py`.

## Programmatic flows

### Flow IR

`Flow`, `FlowNode`, and `FlowEdge` are re-exported from AbstractRuntime so there is a single source of truth for semantics.

```python
from abstractflow import Flow, FlowNode, FlowEdge
```

Evidence: `abstractflow/core/flow.py`, `abstractflow/__init__.py`.

### FlowRunner

`FlowRunner` compiles a `Flow` to a runtime `WorkflowSpec` and executes it using an AbstractRuntime `Runtime`.

```python
from abstractflow import FlowRunner
```

Key behaviors:
- Creates a default in-memory runtime when you don‚Äôt provide one.
- Normalizes completion output into `{"success": bool, "result": ...}`.
- Returns `{"waiting": True, ...}` if the flow blocks on durable input.

Evidence: `abstractflow/runner.py`.

### Compilation

Compilation functions are delegated to AbstractRuntime‚Äôs VisualFlow compiler and re-exported:

```python
from abstractflow import compile_flow
```

Evidence: `abstractflow/compiler.py`, `abstractflow/__init__.py`.

## Visual flows (VisualFlow JSON)

### Models

Pydantic models for the portable JSON format:

```python
from abstractflow.visual import VisualFlow, VisualNode, VisualEdge, NodeType, PinType
```

Evidence: `abstractflow/visual/models.py`, `abstractflow/visual/__init__.py`.

### Execute a VisualFlow

Use `execute_visual_flow(...)` for a simple ‚Äúrun and return a result‚Äù call:

```python
from abstractflow.visual import execute_visual_flow
```

For advanced use cases (custom stores/tool execution, or access to run state/ledger), build a runner:

```python
from abstractflow.visual import create_visual_runner
```

Evidence: `abstractflow/visual/executor.py`, `docs/getting-started.md`.

### Interfaces/contracts (optional)

If a host expects a specific IO contract, VisualFlows can declare interface markers in `VisualFlow.interfaces`.

```python
from abstractflow.visual.interfaces import (
    ABSTRACTCODE_AGENT_V1,
    validate_visual_flow_interface,
    apply_visual_flow_interface_scaffold,
)
```

Evidence: `abstractflow/visual/interfaces.py`.

## Workflow bundles (`.flow`)

WorkflowBundle helpers are available as a thin wrapper around AbstractRuntime‚Äôs bundle implementation:

```python
from abstractflow.workflow_bundle import (
    pack_workflow_bundle,
    inspect_workflow_bundle,
    unpack_workflow_bundle,
)
```

Evidence: `abstractflow/workflow_bundle.py`, `docs/cli.md`.

## CLI

The `abstractflow` CLI entry point is declared in `pyproject.toml` (`project.scripts`) and implemented in:
- `abstractflow/cli.py`

Evidence: `pyproject.toml`, `abstractflow/cli.py`.

---
file: docs/faq.md
---

# FAQ

See also: `docs/getting-started.md`, `docs/api.md`, `docs/architecture.md`.

## What is AbstractFlow?

AbstractFlow is a Python library for defining and executing **durable** AI workflows:
- Programmatic graphs (`Flow` + `FlowRunner`)
- Portable visual workflows (`VisualFlow` JSON) that can run outside the editor

Evidence: `abstractflow/runner.py`, `abstractflow/visual/models.py`, `abstractflow/visual/executor.py`.

## Is AbstractFlow production-ready?

Not yet. The package is marked **Pre-alpha** and may introduce breaking changes.

Evidence: `pyproject.toml` (`Development Status :: 2 - Pre-Alpha`).

## What‚Äôs the difference between `Flow` and `VisualFlow`?

- `Flow`: programmatic flow IR (re-exported from AbstractRuntime) used by `FlowRunner`.
- `VisualFlow`: portable JSON authoring format (Pydantic models) produced by the web editor and runnable from any host.

Evidence: `abstractflow/core/flow.py`, `abstractflow/visual/models.py`, `abstractflow/runner.py`.

## Can I execute a VisualFlow JSON without running the web editor?

Yes. Load the JSON into `VisualFlow` and run it with `abstractflow.visual.execute_visual_flow(...)` (or build a runner with `create_visual_runner(...)` if you need access to the runtime/run state).

Evidence: `abstractflow/visual/executor.py`.

## How do subflows work?

Subflows are VisualFlows referenced by id from nodes of type `subflow`:
- `node.data["subflowId"]` (legacy: `flowId`)

When executing, you must provide a mapping of all flows by id: `flows={flow_id: VisualFlow, ...}`.

Evidence: `abstractflow/visual/executor.py`, `docs/visualflow.md`.

## How do ‚Äúwaiting‚Äù runs work? How do I resume?

Some nodes intentionally block on external input (e.g. user/event/schedule waits).
- `FlowRunner.run()` returns `{"waiting": True, ...}` when blocked.
- The web editor resumes blocked runs over WebSocket (`type:"resume"`).

Evidence: `abstractflow/runner.py`, `web/backend/routes/ws.py`, `docs/web-editor.md`.

## How do custom events work in VisualFlow?

For VisualFlows, `VisualSessionRunner` starts `on_event` listeners as **child runs** in the same session and ticks them so `emit_event` branches progress.

Evidence: `abstractflow/visual/session_runner.py`, wiring in `abstractflow/visual/executor.py`.

## Does `pip install abstractflow` include the web editor UI?

No. The published Python package is under `abstractflow/`. The visual editor is a reference/dev app under `web/` and is run from source.

Evidence: repo layout in `docs/architecture.md`, packaging config in `pyproject.toml` (`tool.setuptools.packages.find`).

## Where does the web editor store flows and run data?

When you run the backend from `web/`:
- Flows are stored in `web/flows/*.json` (relative path `./flows`).
- Runtime persistence defaults to `web/runtime/` (override with `ABSTRACTFLOW_RUNTIME_DIR`).

Evidence: `web/backend/routes/flows.py` (`FLOWS_DIR = Path("./flows")`), `web/backend/services/runtime_stores.py`.

## How does tool / file access work (security)?

The web backend creates a per-run workspace directory and wraps tool execution with workspace scoping:
- Workspace base: `ABSTRACTFLOW_BASE_EXECUTION` (or `/tmp` / OS temp)
- Workspace root is injected into `input_data` (`workspace_root`) and used to scope tools

Evidence: `web/backend/services/execution_workspace.py`, `abstractflow/visual/workspace_scoped_tools.py`, `web/backend/routes/ws.py`, `web/backend/routes/flows.py`.

## How do I package and share workflows?

Use WorkflowBundle (`.flow`):
- CLI: `abstractflow bundle pack|inspect|unpack`
- The bundle format and packer are owned by AbstractRuntime; AbstractFlow provides a thin wrapper.

Evidence: `abstractflow/cli.py`, `abstractflow/workflow_bundle.py`, tests in `tests/test_workflow_bundle_pack.py`.

## Do I need an AbstractGateway?

Not necessarily. VisualFlow execution is runtime-based and can run locally with AbstractCore integration. The web editor can optionally connect to a gateway (URL/token) for catalogs and bundle upload/reload.

Evidence: `abstractflow/visual/executor.py` (gateway token resolution), `web/backend/services/gateway_connection.py`, `web/backend/routes/flows.py` (publish/upload/reload).

## Why do I see pins in `node.data.inputs/outputs` instead of `node.inputs/outputs`?

Saved flows from the editor store pin metadata under `node.data.inputs` / `node.data.outputs`. The top-level `inputs` / `outputs` fields may exist but are often empty.

Evidence: `abstractflow/visual/interfaces.py` (`_pin_types` reads `node.data.*`), sample flows in `web/flows/*.json`.

## Where is the ‚Äúcompiler‚Äù implemented?

Compilation semantics live in AbstractRuntime‚Äôs VisualFlow compiler. This package delegates and re-exports:
- `abstractflow/compiler.py` (compile functions)
- `abstractflow/adapters/*` and `abstractflow/visual/builtins.py` (node adapters/builtins)

Evidence: `abstractflow/compiler.py`, `abstractflow/adapters/*`, `abstractflow/visual/builtins.py`.

---
file: docs/visualflow.md
---

# VisualFlow (portable JSON workflow format)

`VisualFlow` is the portable workflow document produced by the visual editor in `web/frontend/` and persisted by the backend in `web/backend/`.

The schema lives in `abstractflow/visual/models.py` (Pydantic models). Any host can:
- load/validate the JSON into `VisualFlow`
- execute it using `abstractflow.visual` helpers

See also: `docs/getting-started.md`, `docs/faq.md`, `docs/web-editor.md`, `docs/architecture.md`.

## Minimal schema (what to expect)

- `VisualFlow`
  - `id: str`
  - `name: str`, `description: str`
  - `interfaces: list[str]` (optional host contracts)
  - `nodes: list[VisualNode]`, `edges: list[VisualEdge]`
  - `entryNode: str | null` (optional, Blueprint-style execution root)
- `VisualNode`
  - `id: str`, `type: NodeType`, `position: {x,y}`
  - `data: dict` (node config + pin metadata)
- `VisualEdge`
  - `source`, `sourceHandle`, `target`, `targetHandle`

Evidence: `abstractflow/visual/models.py`.

## Node types and pins

- The full list of node types is `NodeType` in `abstractflow/visual/models.py`.
- Pin types are `PinType` in `abstractflow/visual/models.py` (and mirrored for UI concerns in `web/frontend/src/types/flow.ts`).

Two edge ‚Äúkinds‚Äù are used by convention:
- **Execution edges**: connect to the target handle `exec-in` (Blueprint-style control flow).
- **Data edges**: connect non-exec handles and carry values between pins.

Evidence:
- VisualFlow runner wiring uses execution-graph reachability (`targetHandle == "exec-in"`) in `abstractflow/visual/executor.py`.
- UI colors data edges by pin type in `web/frontend/src/components/Canvas.tsx`.

Note on pins in saved JSON:
- The editor persists pin definitions under `node.data.inputs` / `node.data.outputs`.
- The top-level `node.inputs` / `node.outputs` fields may be present but empty.

Evidence: `abstractflow/visual/interfaces.py` (`_pin_types` reads `node.data.*`) and sample flows in `web/flows/*.json`.

## Subflows

Subflows are regular VisualFlows referenced by id from a node of type `subflow`.

Convention:
- `node.type == "subflow"`
- `node.data["subflowId"]` holds the referenced flow id (legacy key `flowId` is tolerated).

Evidence:
- Runner wiring resolves subflows in `abstractflow/visual/executor.py` (`subflowId` / legacy `flowId`)
- Bundle packing is delegated to AbstractRuntime via `abstractflow/workflow_bundle.py` (see `tests/test_workflow_bundle_pack.py`).
- Tests: `tests/test_visual_subflow_*.py`, `tests/test_workflow_bundle_pack.py`

## Interfaces (optional host contracts)

`VisualFlow.interfaces` is a list of interface markers a host can interpret as ‚Äúthis workflow supports a known IO contract‚Äù.

AbstractFlow ships:
- `abstractcode.agent.v1` (`ABSTRACTCODE_AGENT_V1`) with validators and scaffolding helpers

Evidence: `abstractflow/visual/interfaces.py`.

---
file: docs/web-editor.md
---

# Visual editor (reference app in `web/`)

This repository includes a reference visual editor:
- FastAPI backend: `web/backend/`
- React frontend: `web/frontend/`

It is intended for development and as a reference host for executing VisualFlows. It is not packaged as an installable Python module on PyPI.

See also: `docs/getting-started.md`, `docs/faq.md`, `docs/visualflow.md`, `docs/architecture.md`.

## Run (dev mode)

Terminal 1 (backend):

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e ".[server,agent]"

cd web
python -m backend --reload --port 8080
```

Terminal 2 (frontend):

```bash
cd web/frontend
npm install
npm run dev
```

Open:
- Frontend: http://localhost:3003 (Vite dev server; see `web/frontend/package.json`)
- Backend: http://localhost:8080/api/health (FastAPI; see `web/backend/main.py`)

## Run (single-process ‚Äúproduction‚Äù mode)

Build the frontend and let the backend serve it:

```bash
cd web/frontend
npm install
npm run build

cd ../
python -m backend --port 8080
```

Evidence: `web/backend/main.py` serves `web/frontend/dist` when it exists.

## Where data is stored

- Flows: `./flows/*.json` relative to the backend working directory.
  - If you run the backend from `web/`, that becomes `web/flows/`.
  - Evidence: `FLOWS_DIR = Path("./flows")` in `web/backend/routes/flows.py`.
- Runtime persistence (runs/ledger/artifacts): defaults to `web/runtime/`.
  - Override with `ABSTRACTFLOW_RUNTIME_DIR`.
  - Evidence: `web/backend/services/runtime_stores.py`.

## Gateway connectivity (optional)

The backend can talk to an AbstractGateway for provider/model catalogs and remote execution.

Common env vars / flags:
- `ABSTRACTFLOW_GATEWAY_URL` (or `ABSTRACTGATEWAY_URL`)
- `ABSTRACTGATEWAY_AUTH_TOKEN` (legacy: `ABSTRACTFLOW_GATEWAY_AUTH_TOKEN`)
- CLI flags: `python -m backend --gateway-url ... --gateway-token ...` (see `web/backend/cli.py`)

Evidence: `web/backend/services/gateway_connection.py`, `abstractflow/visual/executor.py`.

## WebSocket execution

The Run UI uses WebSocket messages:
- `{ "type": "run", "input_data": {‚Ä¶} }`
- `{ "type": "resume", "response": "‚Ä¶" }`
- `{ "type": "control", "action": "pause|resume|cancel", "run_id": "‚Ä¶" }`

Evidence: `web/backend/routes/ws.py`.

---
file: docs/cli.md
---

# CLI (`abstractflow`)

AbstractFlow ships a small CLI focused on **WorkflowBundle** (`.flow`) utilities.

Entry point:
- `abstractflow` (declared in `pyproject.toml` ‚Üí `project.scripts`)
- implementation: `abstractflow/cli.py`

See also: `docs/getting-started.md`, `docs/faq.md`, `docs/visualflow.md`, `docs/architecture.md`.

## WorkflowBundle (.flow)

A `.flow` file is a zip bundle containing:
- `manifest.json`
- `flows/<flow_id>.json` (one or more VisualFlow JSON documents)

Bundling semantics are shared with AbstractRuntime:
- AbstractFlow CLI uses `abstractruntime.workflow_bundle` under the hood.
- Evidence: `abstractflow/workflow_bundle.py`, `abstractflow/cli.py`.

## Commands

Pack a bundle from a root VisualFlow JSON (includes referenced subflows as determined by the AbstractRuntime packer):

```bash
abstractflow bundle pack web/flows/ac-echo.json --out /tmp/ac-echo.flow
```

Common options (see `abstractflow bundle pack --help`):
- `--flows-dir <dir>`: where to find `<flow_id>.json` files (defaults to the root file‚Äôs directory)
- `--bundle-id <id>`, `--bundle-version <x.y.z>`
- `--entrypoint <flow_id>` (repeatable)

Inspect a bundle manifest:

```bash
abstractflow bundle inspect /tmp/ac-echo.flow
```

Unpack to a directory:

```bash
abstractflow bundle unpack /tmp/ac-echo.flow --dir /tmp/ac-echo
```

Evidence:
- Delegation to AbstractRuntime: `abstractflow/workflow_bundle.py`
- CLI implementation: `abstractflow/cli.py`
- Tests: `tests/test_workflow_bundle_pack.py`

---
file: docs/architecture.md
---

# AbstractFlow ‚Äî Architecture (Current)

> Updated: 2026-02-04  
> Scope: describes **implemented behavior** in this repository (no roadmap claims).

AbstractFlow is a workflow authoring + orchestration layer built on:
- **AbstractRuntime**: durable runs, waits, subworkflows, stores (`RunStore`/`LedgerStore`/`ArtifactStore`)
- **AbstractCore** (via runtime integration): LLM + tool effects
- **AbstractAgent** (optional): Agent node subworkflows (ReAct)
- **AbstractMemory** (optional): memory/KG nodes

See also: `docs/getting-started.md`, `docs/api.md`, `docs/faq.md`, `docs/visualflow.md`, `docs/web-editor.md`, `docs/cli.md`.

## Repository layout (what ships where)

```
abstractflow/                  # Published Python package
  __init__.py                  # Public API exports
  core/flow.py                 # Flow IR re-export (from AbstractRuntime)
  runner.py                    # FlowRunner (runtime-backed)
  compiler.py                  # Compiler shim (delegates to AbstractRuntime)
  visual/                      # VisualFlow models + portable execution wiring
  adapters/                    # Adapter re-exports (delegates to AbstractRuntime)
  cli.py                       # `abstractflow` CLI
  workflow_bundle.py           # Bundle helpers (delegates to AbstractRuntime)
docs/                          # Human docs (this folder)
web/                           # Reference visual editor app (not packaged on PyPI)
  backend/                     # FastAPI backend (CRUD + websocket execution)
  frontend/                    # React editor + run UI
  flows/                       # Default flow storage when running backend from `web/`
  runtime/                     # Default runtime persistence when running backend from `web/`
tests/                         # Test suite
```

## High-level data and execution flow

```mermaid
flowchart LR
  subgraph Authoring
    FE[web/frontend<br/>React editor] -->|save/load VisualFlow JSON| BE[web/backend<br/>FastAPI]
    BE -->|persists| FLOWS[(web/flows/*.json)]
  end

  subgraph Execution
    HOST[Host process<br/>(web backend / CLI / 3rd party)] -->|validate| VF[VisualFlow models<br/>abstractflow/visual/models.py]
    HOST -->|create_visual_runner| WIRE[Runtime wiring<br/>abstractflow/visual/executor.py]
    WIRE --> RT[AbstractRuntime Runtime<br/>tick/resume]
    RT --> STORES[(RunStore / LedgerStore / ArtifactStore)]
    RT -->|LLM_CALL, TOOL_CALLS| AC[AbstractCore integration]
    RT -->|START_SUBWORKFLOW| REG[WorkflowRegistry]
  end

  BE -->|WS: run/resume/control| HOST
```

## Portable data model: VisualFlow JSON

The portable authoring format is `VisualFlow` (Pydantic models):
- `VisualFlow`, `VisualNode`, `VisualEdge`, `NodeType`, `PinType`, ‚Ä¶

Evidence: `abstractflow/visual/models.py`.

Key portability rule (enforced by design): the JSON must contain enough configuration to execute outside the web backend. Hosts may add storage, auth, and UI around it, but execution should remain host-independent.

## Compilation and execution (portable)

### VisualFlow ‚Üí Flow IR

AbstractFlow delegates ‚ÄúVisualFlow ‚Üí Flow IR‚Äù semantics to AbstractRuntime:
- `abstractflow.visual.executor.visual_to_flow()` calls `abstractruntime.visualflow_compiler.visual_to_flow(...)`.

Evidence: `abstractflow/visual/executor.py`.

### Flow IR ‚Üí WorkflowSpec

AbstractFlow delegates compilation to AbstractRuntime:
- `abstractflow.compiler.compile_flow` is re-exported from `abstractruntime.visualflow_compiler.compiler`.

Evidence: `abstractflow/compiler.py`.

### Running (FlowRunner)

`FlowRunner` owns host-friendly execution convenience:
- creates a default in-memory runtime when you don‚Äôt provide one
- normalizes outputs to `{"success": bool, "result": ...}` for callers
- can auto-drive nested `SUBWORKFLOW` waits in non-interactive contexts

Evidence: `abstractflow/runner.py`, tests in `tests/test_runner.py`.

## VisualFlow execution wiring (host responsibilities)

The key host entrypoint is:
- `abstractflow.visual.executor.create_visual_runner(...)`

It wires the runtime based on **what is present in the flow tree**:
- registers subflows/agent workflows when needed (workflow registry)
- enables artifact storage when memory nodes are present
- wires AbstractCore effect handlers when LLM/tool nodes are present
- optionally installs AbstractMemory KG effect handlers when `memory_kg_*` nodes are present

Evidence: `abstractflow/visual/executor.py`.

## Session-scoped events (VisualSessionRunner)

VisualFlows that include custom events (`on_event` / `emit_event`) are executed with a session-aware runner:
- `VisualSessionRunner` starts derived event-listener workflows as **child runs** in the same session.
- During `run()`, it also ticks those child runs so `EMIT_EVENT` branches make progress without a separate host loop.

Evidence: `abstractflow/visual/session_runner.py`, wiring in `abstractflow/visual/executor.py`, tests in `tests/test_visual_custom_events.py`.

## Web editor host (FastAPI + WebSockets)

The reference host in `web/` provides:
- Flow CRUD (`web/backend/routes/flows.py`) storing `./flows/*.json` relative to its working dir
- Durable stores for runs/ledger/artifacts (`web/backend/services/runtime_stores.py`)
- WebSocket execution (`web/backend/routes/ws.py`) with message types:
  - `{ "type": "run", "input_data": {‚Ä¶} }`
  - `{ "type": "resume", "response": "‚Ä¶" }`
  - `{ "type": "control", "action": "pause|resume|cancel", "run_id": "‚Ä¶" }`

See `docs/web-editor.md` for run instructions.

## Workflow bundles (`.flow`)

WorkflowBundles package a root VisualFlow JSON plus any referenced subflows into a single `.flow` (zip) file (manifest + flow JSON files).

- CLI: `abstractflow bundle pack|inspect|unpack` (`abstractflow/cli.py`)
- Implementation delegates to AbstractRuntime: `abstractflow/workflow_bundle.py`
- Format/packing semantics are owned by AbstractRuntime; AbstractFlow is a thin wrapper.

Evidence: `tests/test_workflow_bundle_pack.py`, `abstractflow/workflow_bundle.py`.

## What AbstractFlow owns vs delegates

**Owns in this repo**
- VisualFlow schema (`abstractflow/visual/models.py`)
- Host wiring helpers (`abstractflow/visual/executor.py`, `abstractflow/visual/session_runner.py`)
- Public runner conveniences (`abstractflow/runner.py`)
- Reference web editor app (`web/`)
- CLI wrapper (`abstractflow/cli.py`)

**Delegates to AbstractRuntime**
- Compilation semantics and builtins (`abstractflow/compiler.py`, `abstractflow/visual/builtins.py`)
- Adapter implementations (`abstractflow/adapters/*`)
- WorkflowBundle format and IO (`abstractflow/workflow_bundle.py`)

---
file: CHANGELOG.md
---

# Changelog

All notable changes to AbstractFlow will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **AbstractCode UI event demo flows** (`web/flows/*.json`):
  - `acagent_message_demo.json`: `abstractcode.message`
  - `acagent_ask_demo.json`: durable ask+wait via `wait_event.prompt`
  - `acagent_tool_events_demo.json`: `abstractcode.tool_execution` + `abstractcode.tool_result`
- **Tool observability wiring improvements (Visual nodes)**:
  - `LLM Call` exposes `tool_calls` as a first-class output pin (same as `result.tool_calls`) for easier wiring into `Tool Calls` / `Emit Event`.
  - `Agent` exposes best-effort `tool_calls` / `tool_results` extracted from its scratchpad trace (post-run ergonomics).
- **Pure Utility Nodes (Runtime-backed)**:
  - `Stringify JSON` (`stringify_json`): Render JSON (or JSON-ish strings) into text with a `mode` dropdown (`none` | `beautify` | `minified`). Implementation delegates to `abstractruntime.rendering.stringify_json` for consistent host behavior.
  - `Agent Trace Report` (`agent_trace_report`): Render an agent scratchpad (`node_traces`) into a condensed Markdown timeline of LLM calls and tool actions (full tool args + results, no truncation). Implementation delegates to `abstractruntime.rendering.render_agent_trace_markdown`.

### Changed
- **Run Flow modal (array parameters)**: Array pins now render as a Blueprint-style item list (add/remove items) with a "Raw JSON (advanced)" escape hatch for non-string arrays.

### Fixed
- **FlowRunner SUBWORKFLOW auto-drive**: `FlowRunner.run()` no longer hangs if the runtime registry contains only subworkflow specs (common in unit tests). It now falls back to the runner‚Äôs own root `WorkflowSpec` when resuming/bubbling parents.

## [0.3.1] - 2026-02-04

### Added
- **User-facing documentation set** for public release:
  - Core docs: `README.md`, `docs/getting-started.md`, `docs/architecture.md`, `docs/api.md`, `docs/faq.md`
  - Repo policies: `CONTRIBUTING.md`, `SECURITY.md`, `ACKNOWLEDMENTS.md`
  - Agentic index: `llms.txt`, `llms-full.txt`

### Changed
- **Documentation accuracy + structure**: refreshed docs to match the implemented code (VisualFlow portability, runtime wiring, CLI bundle tooling, web editor layout) and improved cross-references for first-time users.

## [0.3.0] - 2025-01-06

### Added
- **VisualFlow Interface System** (`abstractflow/visual/interfaces.py`): Declarative workflow interface markers for portable host validation, enabling workflows to be run as specialized capabilities with known IO contracts
  - `abstractcode.agent.v1` interface: Host-configurable prompt ‚Üí response contract for running a workflow as an AbstractCode agent
  - Interface validation with required/recommended pin specifications (provider/model/tools/prompt/response)
  - Auto-scaffolding support: enabling `abstractcode.agent.v1` auto-creates `On Flow Start` / `On Flow End` nodes with required pins
- **Structured Output Support**: Visual `LLM Call` and `Agent` nodes accept optional `response_schema` input pin (JSON Schema object) for schema-conformant responses
  - New literal node `JSON Schema` (`json_schema`) to author schema objects
  - New `JsonSchemaNodeEditor` UI component for authoring schemas in the visual editor
  - Pin-driven schema overrides node config and enables durable structured-output enforcement via AbstractRuntime `LLM_CALL`
- **Tool Calling Infrastructure**:
  - Visual `LLM Call` nodes support optional **tool calling** via `tools` allowlist input (pin or node config)
  - Expose structured `result` output object (normalized LLM response including `tool_calls`, `usage`, `trace_id`)
  - Inline tools dropdown in node UI (when `tools` pin not connected)
  - Visual `Tool Calls` node (`tool_calls`) to execute tool call requests via AbstractRuntime `EffectType.TOOL_CALLS`
  - New pure node `Tools Allowlist` (`tools_allowlist`) with inline multi-select for workflow-scope tool lists
  - Dedicated `tools` pin type (specialized `string[]`) for `On Flow Start` parameters
- **Control Flow & Loop Enhancements**:
  - New control node `For` (`for`) for numeric loops with `start`/`end`/`step` inputs and `i`/`index` outputs
  - `While` node now exposes `index` output pin (0-based iteration count) and `item:any` output pin for parity with `ForEach`
  - `Loop` (Foreach) now invalidates cached pure-node outputs per-iteration (fixes scratchpad accumulation)
- **Workflow Variables**:
  - New pure node `Variable` (`var_decl`) to declare workflow-scope persistent variables with explicit types
  - New pure node `Bool Variable` (`bool_var`) for boolean variables with typed outputs
  - New execution node `Set Variables` (`set_vars`) to update multiple variables in a single step
  - New execution node `Set Variable Property` (`set_var_property`) to update nested object properties
  - `Get Variable` (`get_var`) reads from durable `run.vars` by dotted path
  - `Set Variable` (`set_var`) updates `run.vars` with pass-through execution semantics
- **Custom Events** (Blueprint-style):
  - `On Event` listeners compiled into dedicated durable subworkflows (auto-started, session-scoped)
  - `Emit Event` node dispatches durable events via AbstractRuntime
- **Run History & Observability**:
  - New web API endpoints: `/api/runs`, `/api/runs/{run_id}/history`, `/api/runs/{run_id}/artifacts/{artifact_id}`
  - UI "Run History" picker (üïò) to open past runs and apply pause/resume/cancel controls
  - Run modal shows clickable **run id** pill (hover ‚Üí copy to clipboard)
  - Run modal header token badge reflects cumulative LLM usage across entire run tree
  - WebSocket events include JSON-safe ISO timestamp (`ts`)
  - Runtime node trace entries streamed incrementally over WebSocket (`trace_update`)
  - Agent details panel renders live sub-run trace with expandable prompts/responses/errors
- **Pure Utility Nodes**:
  - `Parse JSON` (`parse_json`) to convert JSON/JSON-ish strings into objects
  - `coalesce` (first non-null selection by pin order)
  - `string_template` (render `{{path.to.value}}` with filters: json, join, trim)
  - `array_length`, `array_append`, `array_dedup`
  - `Compare` (`compare`) now has `op` input pin supporting `==`, `>=`, `>`, `<=`, `<`
  - `get` (Get Property) supports `default` input and safer nested path handling (e.g. `a[0].b`)
- **Memory Node Enhancements**:
  - `Memorize` (`memory_note`) adds optional `location` input
  - `Memorize` supports **Keep in context** toggle to rehydrate notes into `context.messages`
  - `Recall` (`memory_query`) adds `tags_mode` (all/any), `usernames`, `locations` inputs
- **Subflow Enhancements**:
  - `Subflow` supports **Inherit context** toggle to seed child run's `context.messages` from parent
  - `multi_agent_state_machine` accepts `workspace_root` parameter to scope agent file/system tools
- **Visual Execution Defaults**:
  - Default **LLM HTTP timeout** (7200s, overrideable via `ABSTRACTFLOW_LLM_TIMEOUT_S`)
  - Default **max output token cap** (4096, overrideable via `ABSTRACTFLOW_LLM_MAX_OUTPUT_TOKENS`)
- **UI/UX Improvements**:
  - Run preflight validation panel with itemized "Fix before running" checklist
  - Node tooltips available in palette and on-canvas (hover > 1s)
  - Node palette exposed transforms (`trim`, `substring`, `format`) and math ops (`modulo`, `power`)
  - Enhanced `PropertiesPanel` with structured output configuration
  - Improved `RunFlowModal` with better input validation and error display
  - JSON validation and error handling across executor and frontend (`web/frontend/src/utils/validation.ts`)

### Changed
- **Workflow-Agent Interface UX**: Enabling `abstractcode.agent.v1` auto-scaffolds `On Flow Start` / `On Flow End` pins (provider/model/tools)
- **Memory Nodes UX**: `memory_note` labeled **Memorize** (was Remember) to align with AbstractCode `/memorize`
- **Flow Library Modal**: Flow name/description edited via inline pencil icons (removed Rename/Edit Description buttons)
- **Run Modal UX**:
  - String inputs default to 3-line textarea
  - Modal actions pinned in footer (body scrolls)
  - No truncation of sub-run/memory previews (full content on demand)
  - JSON panels (`Raw JSON`, `Trace JSON`, `Scratchpad`) syntax-highlighted
- **Node Palette Organization**:
  - Removed **Effects** category
  - Added **Memory** category (memories + file IO)
  - Added **Math** category (after Variables)
  - Moved **Delay** to **Events**
  - Split into **Literals**, **Variables**, **Data** (renamed from "Data" to **Transforms**)
  - Reordered **Control** nodes (loops ‚Üí branching ‚Üí conditions)
  - `System Date/Time` moved to **Events**
  - `Provider Catalog` + `Models Catalog` moved to **Literals**
  - `Tool Calls` moved from **Effects** to **Core** (reordered: Subflow, Agent, LLM Call, Tool Calls, Ask User, Answer User)
- **Models Catalog**: Removed deprecated `allowed_models` input pin (in-node multi-select synced with right panel)
- **Node/Pin Tooltips**: Appear after 2s hover, rendered in overlay layer (no clipping)
- **Python Code Nodes**: Include in-node **Edit Code** button; editor injects "Available variables" comment block
- **Execution Highlighting**: Stronger, more diffuse bloom for readability during runs; afterglow decays smoothly (3s), highlights only taken edges
- **Data Edges**: Colored by data type (based on source pin type)

### Fixed
- **Recursive Subflows**: Visual data-edge cache (`flow._node_outputs`) now isolated per `run_id` to prevent stale outputs leaking across nested runs (fixes self/mutual recursion with pure nodes like `compare`, `subtract`)
- **Durable Persistence**: `on_flow_start` no longer leaks internal `_temp` into cached node outputs (prevented `RecursionError: maximum recursion depth exceeded`)
- **WebSocket Run Controls**: Pause/resume/cancel no longer block on per-connection execution lock (responsive during long-running LLM/Agent nodes)
- **WebSocket Resilience**:
  - Controls resilient to transient disconnects (can send with explicit `run_id`, UI reconnects-and-sends)
  - Execution resilient to UI disconnects (dropped connection doesn't cancel in-flight run)
- **VisualFlow Execution**: Ignores unreachable/disconnected execution nodes (orphan `llm_call`/`subflow` can't fail initialization)
- **Loop Nodes**:
  - `Split` avoids spurious empty trailing items (e.g. `"A@@B@@"`) so `Loop` doesn't execute extra empty iteration
  - Scheduler-node outputs in WebSocket `node_complete`: Loop/While/For sync persisted `{index,...}` outputs to `flow._node_outputs` (UI no longer shows stale index)
- **Pure Node Behavior**:
  - `Concat` infers stable pin order (a..z) when template metadata missing
  - `Set Variable` defaulting for typed primitives: `boolean/number/string` pins default to `false/0/""` instead of `None`
- **Agent Nodes**: Reset per-node state when re-entered (e.g. inside `Loop` iterations) so each iteration re-resolves inputs
- **Run Modal Observability**:
  - WebSocket `node_start`/`node_complete` events include `runId` (distinguish root vs child runs)
  - Visual Agent nodes start ReAct subworkflow in **async+wait** mode for incremental ticking
  - Run history replay synthesizes missing `node_complete` events for steps left open in durable ledger
- **Canvas Highlighting**: Robust to fast child-run emissions (race with `node_start` before `runId` state update fixed)
- **WebSocket Subworkflow Waits**: Correctly close waiting node when run resumes past `WAITING(reason=SUBWORKFLOW)`
- **Web Run History**: Reliably shows persisted runs regardless of server working directory (backend defaults to `web/runtime` unless `ABSTRACTFLOW_RUNTIME_DIR` set)
- **Cancel Run**: No longer surfaces as `flow_error` from `asyncio.CancelledError` (treated as expected control-plane operation)
- **Markdown Code Blocks**: "Copy" now copies original raw code (preserves newlines/indentation) after syntax highlighting

### Technical Details
- **13 commits**, **48 files changed**: 12,142 insertions, 368 deletions
- New module: `abstractflow/visual/interfaces.py` (347 lines)
- New UI component: `web/frontend/src/components/JsonSchemaNodeEditor.tsx` (460 lines)
- New tests: `test_visual_interfaces.py`, `test_visual_agent_structured_output_pin.py`, `test_visual_llm_call_structured_output_pin.py`, `test_visual_subflow_recursion.py`
- Compiler enhancements: Interface validation, per-run cache isolation, structured output pin support
- Executor optimizations: Performance improvements for VisualFlow execution
- 12 new example workflow JSON files in `web/flows/`

### Notes
- This repository includes the published Python package (`abstractflow/`) and a reference visual editor app (`web/`).

## [0.1.0] - 2025-01-15

### Added
- Initial placeholder package to reserve PyPI name
- Basic project structure and packaging configuration
- Comprehensive README with project vision and roadmap
- MIT license and contribution guidelines
- CLI placeholder with planned command structure

### Notes
- This is a placeholder release to secure the `abstractflow` name on PyPI
- No functional code is included in this version
- Follow the GitHub repository for development updates and release timeline

---
file: CONTRIBUTING.md
---

# Contributing

Thanks for your interest in contributing to AbstractFlow. Contributions are welcome in the form of:
- Bug reports and reproducible test cases
- Documentation improvements
- Fixes and small features (via pull requests)

Security issues: please follow `SECURITY.md` and avoid public disclosure.

## Development setup

Requirements:
- Python **3.10+**
- Node.js **18+** (only if you work on the visual editor in `web/frontend/`)

Create a virtual environment and install the package in editable mode:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e ".[dev,server,agent]"
```

Run tests:

```bash
pytest -q
```

## Working on the visual editor

The visual editor is a reference/dev app under `web/`:
- Backend: FastAPI (`web/backend/`)
- Frontend: React/Vite (`web/frontend/`)

Run instructions: `docs/web-editor.md`.

## Style and quality

- Keep changes focused and well-scoped.
- Prefer adding/adjusting tests when changing behavior (`tests/`).
- Keep public docs concise and accurate; update cross-references when adding new docs (`docs/README.md` is the index).
- If you change docs, regenerate the full agentic pack: `python scripts/generate_llms_full.py` (updates `llms-full.txt`).

Optional formatting (if you use it locally):

```bash
python -m black .
python -m isort .
```

---
file: SECURITY.md
---

# Security policy

We take security reports seriously and appreciate responsible disclosure.

## Reporting a vulnerability

Please **do not** open a public GitHub issue for security-sensitive reports.

Instead, report vulnerabilities by email:
- `contact@abstractflow.ai`

Include as much of the following as possible:
- A clear description of the issue and potential impact
- Steps to reproduce (or a minimal proof-of-concept)
- Affected component(s) (e.g. `abstractflow` library vs `web/` editor)
- Version information (`abstractflow.__version__`, Python version, OS)

We will respond as quickly as we can and coordinate a fix and disclosure timeline with you.

## Supported versions

AbstractFlow is currently **Pre-alpha**. We recommend staying on the latest patch release.

Evidence: `pyproject.toml` (`Development Status :: 2 - Pre-Alpha`).

---
file: ACKNOWLEDMENTS.md
---

# Acknowledgments

AbstractFlow is built on the shoulders of many projects and ideas. Thank you to the maintainers and contributors of the libraries and tools that make this project possible.

## Inspiration

- The visual workflow UX is inspired by Unreal Engine (UE4/UE5) Blueprints: execution pins, typed pins, and ‚Äúgraph as program‚Äù.

Evidence: `docs/architecture.md`.

## Core building blocks

- AbstractRuntime (durable execution kernel: runs, waits, ledgers, artifacts)
- AbstractCore (providers/models/tools integration used by runtime effects)
- AbstractAgent (optional ReAct/CodeAct agent workflows used by the Visual Agent node)

See `README.md` for links to the upstream repositories.

Evidence: `pyproject.toml` (dependencies and extras), `abstractflow/visual/executor.py` (Agent + memory wiring).

## Open-source libraries used in this repo

This list is intentionally focused on **direct dependencies** declared by the repository (plus a small number of optional integrations that are referenced in code). For the authoritative list, use the manifests below.

Evidence: `pyproject.toml`, `web/frontend/package.json`.

### Python package (`abstractflow/`)

Declared runtime dependencies:
- AbstractRuntime
- abstractcore (`abstractcore[tools]`)
- Pydantic
- typing-extensions

Evidence: `pyproject.toml` (`project.dependencies`).

Optional Python extras:
- `abstractflow[agent]`: AbstractAgent
- `abstractflow[server]`: FastAPI, Uvicorn, websockets
- `abstractflow[ui]`: Streamlit, Plotly, NetworkX
- `abstractflow[dev]`: pytest, pytest-asyncio, Black, isort, Flake8, mypy, pre-commit

Evidence: `pyproject.toml` (`project.optional-dependencies`).

Optional integration (not installed by default):
- AbstractMemory: used when executing `memory_kg_*` nodes; requires `abstractmemory` (and a LanceDB-backed store when configured).

Evidence: `abstractflow/visual/executor.py` (imports + error messages for missing installs).

### Reference web editor (`web/`)

Backend (FastAPI):
- FastAPI (API + WebSockets)
- Uvicorn (ASGI server)

Evidence: `web/backend/main.py`, `pyproject.toml` (`server` extra).

Frontend (React/Vite):
- React, React DOM
- React Flow (graph editor)
- Vite, TypeScript
- Monaco editor (`@monaco-editor/react`)
- TanStack Query (`@tanstack/react-query`)
- Zustand (state)
- DOMPurify (HTML sanitization)
- Marked (Markdown rendering)
- clsx (className composition)
- react-hot-toast (toasts)

Evidence: `web/frontend/package.json`.

Developer tooling (frontend):
- ESLint + TypeScript ESLint
- `@types/*` typings packages

Evidence: `web/frontend/package.json` (`devDependencies`).
